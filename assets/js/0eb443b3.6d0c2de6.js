"use strict";(self.webpackChunkdocusaurus_practice=self.webpackChunkdocusaurus_practice||[]).push([[9150],{4185:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>l,frontMatter:()=>r,metadata:()=>a,toc:()=>p});var o=i(6070),n=i(5710);const r={sidebar_position:3},s="Input Validation",a={id:"fastify/validation",title:"Input Validation",description:"From backend, a rule to keep in mind is to never trust the frontend. For every request, we should validate the input. Although I like zod, fastify-type-provider-zod is a 3rd party library and I had problems using it. Perhaps I just need more time to figure it out, but I decided to use @fastify/type-provider-typebox since I felt that @fastify/type-provider-json-schema-to-ts was too verbose and @fastify/type-provider-zod was not working for me. The interface is very similar to zod, so it was easy to pick up.",source:"@site/docs/fastify/validation.md",sourceDirName:"fastify",slug:"/fastify/validation",permalink:"/learning-notes/docs/fastify/validation",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"notesSidebar",previous:{title:"Creating Routes in Fastify",permalink:"/learning-notes/docs/fastify/routes"},next:{title:"Database",permalink:"/learning-notes/docs/fastify/database"}},d={},p=[{value:"Adding Type Provider",id:"adding-type-provider",level:2},{value:"Defining Types",id:"defining-types",level:2},{value:"Using Types",id:"using-types",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"input-validation",children:"Input Validation"})}),"\n",(0,o.jsxs)(t.p,{children:["From backend, a rule to keep in mind is to never trust the frontend. For every request, we should validate the input. Although I like zod, ",(0,o.jsx)(t.code,{children:"fastify-type-provider-zod"})," is a 3rd party library and I had problems using it. Perhaps I just need more time to figure it out, but I decided to use ",(0,o.jsx)(t.code,{children:"@fastify/type-provider-typebox"})," since I felt that ",(0,o.jsx)(t.code,{children:"@fastify/type-provider-json-schema-to-ts"})," was too verbose and ",(0,o.jsx)(t.code,{children:"@fastify/type-provider-zod"})," was not working for me. The interface is very similar to zod, so it was easy to pick up."]}),"\n",(0,o.jsx)(t.h2,{id:"adding-type-provider",children:"Adding Type Provider"}),"\n",(0,o.jsx)(t.p,{children:"After installing the package, we first update our server to use the type provider:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",metastring:'title="server.ts"',children:"import { TypeBoxTypeProvider } from '@fastify/type-provider-typebox';\nimport { Type } from '@sinclair/typebox';\n\nimport fastify from 'fastify';\n\nconst server = fastify().withTypeProvider<TypeBoxTypeProvider>();\n"})}),"\n",(0,o.jsx)(t.h2,{id:"defining-types",children:"Defining Types"}),"\n",(0,o.jsx)(t.p,{children:"And in server.ts, the first thing that comes to my mind with input validation is the post request for creating a todo. We can define the types in a separate file and import them into our route:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",metastring:'title="schemas/todo.ts"',children:"import { Type } from '@sinclair/typebox';\n\nexport const Todo = Type.Object({\n  id: Type.Number(),\n  description: Type.String(),\n  completed: Type.Boolean(),\n});\nexport type TTodo = Static<typeof Todo>;\n\nexport const Todos = Type.Array(Todo);\n\nexport const PostBody = Type.Pick(Todo, ['description']);\nexport type TPostBody = Static<typeof PostBody>;\n"})}),"\n",(0,o.jsx)(t.h2,{id:"using-types",children:"Using Types"}),"\n",(0,o.jsx)(t.p,{children:"And in our route, we can use the types:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",metastring:'title="routes/todo.ts"',children:"fastify.post<{ Body: TPostBody }>(\n  '/',\n  {\n    schema: {\n      body: PostBody,\n      response: {\n        201: PostBody,\n      },\n    },\n  },\n  (request, reply) => {\n    reply.code(201).send(request.body);\n  }\n);\n"})}),"\n",(0,o.jsx)(t.p,{children:"Here I want to point out that it took me a while to figure out how to pass the types to the route to do the validation. By defining the schema this way, the request body and the reply body are validated, so if either is in the wrong format, the server will throw an error."}),"\n",(0,o.jsx)(t.p,{children:"For the todo, the input is defined based on the todo schema, and the database would be what we are seeing in the next section."})]})}function l(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},5710:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>a});var o=i(758);const n={},r=o.createContext(n);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);